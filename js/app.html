<!DOCTYPE html>
<html lang="pt-br">
    <head>
        <title>My App</title>
        <meta chartset="utf-8" />

        <style>
            body {
                margin: 0;
                background-color: #f0f0f0;
                overflow: hidden;
            }
            canvas {width: 100%; height: 100%}
        </style>
    </head>
    <body>
        <script src="three.js/three.min.js"></script>
        <script src="three.js/CanvasRenderer.js"></script>
        <script src="three.js/Projector.js"></script>
        <script src="three.js/OrbitControls.js"></script>
        <script src="three.js/EditorControls.js"></script>
        <script src="three.js/TransformControls.js"></script>
        <script src="three.js/JSONLoader.js"></script>

        <script>
            var scene, camera, renderer, axes, controls;
	    var rotate = true;
	    var objects = [];

            // Set up renderer, scene and camera
            renderer = new THREE.WebGLRenderer( { antialias: true } );
            renderer.setSize( window.innerWidth, window.innerHeight );
            renderer.setClearColor( 0xeeeedd );
            document.body.appendChild( renderer.domElement );

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            camera.position.z = 30;
            camera.position.x = 2;
            camera.position.y = 5;

            camera.rotation.x = -0.5;

            var editor = new THREE.EditorControls( camera, renderer.domElement );

            controls = new THREE.TransformControls( camera, renderer.domElement );
            controls.addEventListener( 'change', animate );
            scene.add( controls );


	    // Projection

            var projector = new THREE.Projector();
            mouseVector = new THREE.Vector3();

            window.addEventListener( 'mousedown', onMouseDown, false );

            var mouse = new THREE.Vector2();
            var raycaster = new THREE.Raycaster();
            var objects = [];


            // Objects

            var loader = new THREE.JSONLoader();

            loader.load( '../modelos/test.js', function ( geometry, material) {
                var material = new THREE.MeshLambertMaterial( { color: 0x505050 } );
                var object = new THREE.Mesh( geometry, material );
		console.log( geometry.vertices[ 0 ] );
                scene.add( object );
            } );

            var geometry = new THREE.BoxGeometry( 1, 1, 1 );
	    var cubes = new THREE.Object3D();

	    for ( var i = 0; i < 5; i++ ) {
		    var cube = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } ) );
		    
		    cube.position.x = Math.sin( Math.random() * 100 ) * 10;
		    cube.position.y = Math.sin( Math.random() * 100 ) * 10;
		    cube.position.z = Math.sin( Math.random() * 100 ) * 30; 

		    cube.rotation.x = Math.random() * 2 * Math.PI;
		    cube.rotation.y = Math.random() * 2 * Math.PI;
		    cube.rotation.z = Math.random() * 2 * Math.PI;
		    
		    cubes.add( cube );
		    objects.push( cube );
	    }

            controls.attach( cubes.children[ 0 ] );
	    scene.add( cubes );


            // Some fancy animations
            var time = 0;

	    function cubeRotate ( cubes ) {

		for ( var i = 0; i < cubes.children.length; i++ ) {
		
		    time += 0.002;

		    var cube = cubes.children[ i ];
		    // Rotations
		    cube.rotation.x = i + time; 
                    cube.rotation.y = i + time;
    
		    // Positions
		    cube.position.x = Math.sin( i * 4 + time ) * 5;
		    cube.position.y = Math.cos( i * 2 + time ) * 5;
		    cube.position.z = Math.sin( i * 3 + time ) * 5;
		}	
	    }

            // Lights
            var dirLight = new THREE.DirectionalLight( 0xffffff, 0.7 );
            dirLight.position.set( 0, 1, 0 );
            scene.add( dirLight );
            scene.add( new THREE.AmbientLight( 0x555555 ) );

	    var light = new THREE.SpotLight( 0xffffff, 1.5 );
	    light.position.set( 0, 500, 2000 );
	    scene.add( light );
            
            function animate() {

		//if( rotate ) cubeRotate( cubes );

                //requestAnimationFrame( animate );
                renderer.render( scene,camera );

                editor.update();
                controls.update();
            }

            animate();
            
            // Functions

            window.addEventListener( 'keydown', function ( event ) {
                console.log( event.which );
                switch ( event.keyCode ) {
                    case 81:
                          controls.setSpace( controls.space == "local" ? "world" : "local" );
                          break;
                    case 87:
                          controls.setMode( "translate" );
                          break;
                    case 82:
                          controls.setMode( "rotate" );
                          break;
                    case 83:
                          controls.setMode( "scale" );
                          break;
                    case 187:
                    case 107: // +,=,num+
                        controls.setSize( controls.size + 0.1 );
                        break;
                    case 189:
                        controls.setSize( Math.max( controls.size - 0.1, 0.1 ) );
                        break;
                    case 77:
                        console.log( cubes.children[ 0 ] );
                        //editor.enabled == true ? editor.enabled = false : editor.enabled = true;
			saveGeometryToJSON( cubes.children[ 0 ].clone().geometry);
                        break;
                }
            } );

            window.addEventListener( 'resize', onWindowResize, false );

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function onMouseDown( e ) {
                mouse.x = (e.clientX / renderer.domElement.width ) * 2 - 1;
                mouse.y = - (e.clientY / renderer.domElement.height ) * 2 + 1;
                
                raycaster.setFromCamera( mouse, camera );

                var intersects = raycaster.intersectObjects( objects );

		if( intersects.length > 0 ) {
			rotate ? rotate = false : rotate = true;
			//var intersect = intersects[ 0 ];
			//intersect.object.material.color.setHex( Math.random() * 0xffffff );
                } 
            }
            
		function saveGeometryToJSON(geometry) {
	    var i,
		json = {
		    metadata: { 
			formatVersion: 3
		    },
		    scale: 1.000000,
		    materials: [],
		    vertices: [],
		    morphTargets: [],
		    morphColors: [],
		    normals: [],
		    colors: [],
		    uvs: [[]],                  
		    faces: []
		};

	    for (i = 0; i < geometry.vertices.length; i++) {
		json.vertices.push(geometry.vertices[i].position.x);
		json.vertices.push(geometry.vertices[i].position.y);
		json.vertices.push(geometry.vertices[i].position.z);
	    }

	    for (i = 0; i < geometry.faces.length; i++) {
		if (geometry.faces[i].d) {
		    json.faces.push(1);
		} else {
		    json.faces.push(0);                 
		}

		json.faces.push(geometry.faces[i].a);
		json.faces.push(geometry.faces[i].b);
		json.faces.push(geometry.faces[i].c);

		if (geometry.faces[i].d) {
		    json.faces.push(geometry.faces[i].d);
		}

		json.normals.push(geometry.faces[i].normal.x);
		json.normals.push(geometry.faces[i].normal.y);
		json.normals.push(geometry.faces[i].normal.z);
	    }

	    return JSON.stringify(json, null, '<br>');
	}
        </script>
    </body>
</html>

